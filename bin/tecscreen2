#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script that creates simulated time-dependant dTEC FITS screens based on a 2D-polynomial
with sinusoidally varying coefficients

Based on original version written by Peter Dorman, 2019.
"""
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
import logging
import argparse
from astropy.io import fits
from astropy.coordinates import EarthLocation
from losito.obs import Observation
from losito.lib_operations import make_template_image
from losito.MegaScreen import MegaScreen


#TODO: improve this script to include international stations. 
#How should they be treated without inflating the computation time?



class spherical_screen():
    ''' 
    Class to resemble a tecscreen. The screen has a certain height above
    the stations and a resolution. The dimensions of the screen are such
    that the edge stations can view a station_grid_rad big section 
    of the screen. This global screen is given in geodetic coordinates. 
    From the global screen the tecscreens for each station are extracted. 
    
    Parameters
    ----------
    sp : (n, 3) array
        Station positions in cartesian coodinates.
    times : (m,) array dtype float 
        Timestamps of the observations.
    height : float, optional
        Height of the tecscreen above the stations in meter. 
        Default 200 km.
    res : float, optional
        Resolution of the tecscreen in meter. 
        Default 1 km.
    station_grid_rad : float, optional
        How big should the screen of a single station be? This is the 
        angular distance from the reference direction to the station screen
        edge in degree. Default: 4Â° (So the screen is ~ 4 FWHM wide)
    '''
    def __init__(self, sp, times, height = 200e3, res = 1e3, 
                 station_grid_rad = 4.):
        self.sp = EarthLocation.from_geocentric(*sp.T, 'meter') # station pos.
        self.sp_lat = self.sp.to_geodetic().lat.rad # station pos. latitudes
        self.sp_lon = self.sp.to_geodetic().lon.rad # station pos. longitudes
        self.t = times # timestamps of observation
        self.h = height # height of tecscreen
        self.r = 6364.62e3;  # earth radius in m
        self.res = res # resolution of screen grid in m
        self.res_rad = res/(self.r + self.h) # resolution of screen grid in rad
        self.station_grid_rad = np.deg2rad(station_grid_rad) # see class descr.
        self.grid_lat, self.grid_lon = self.get_lat_lon_grid() # initialize
        #station_grid_width: half-width of the station grid in grid index steps
        self.station_grid_width = int(self.delta_angle/self.res_rad)
        self.station_grid_res_rad = res/self.h # get from lat-lon angles to elev
        
    def get_lat_lon_grid(self):
        ''' 
        Initialize the geometry of the global grid.

        Returns
        -------
        grid_lat : ndarray
            Latitude values of the global grid.
        grid_lon : ndarray
            Longitude values of the global grid.
        '''
        r = self.r
        # Calculate extrema of lat/lon to find grid edges.
        # do this using law of sines
        sp_minlat, sp_maxlat = np.min(self.sp_lat), np.max(self.sp_lat)
        sp_minlon, sp_maxlon = np.min(self.sp_lon), np.max(self.sp_lon)
        # delta_angle: angle between ray from earth center to ref_dir
        # and ray from earth center to point on edge of station_screen
        self.delta_angle = (self.station_grid_rad - np.arcsin(
            np.sin(np.pi - self.station_grid_rad) * (r / (r + self.h))))        

        minlat = sp_minlat - self.delta_angle    
        maxlat = sp_maxlat + self.delta_angle
        minlon = sp_minlon - self.delta_angle
        maxlon = sp_maxlon + self.delta_angle       
        #archlength_lat = (maxlat - minlat)*(r + self.h)
        #archlength_lon = (maxlon - minlon)*(r + self.h)
        self.res_lon = int(np.ceil((maxlon - minlon)/self.res_rad))
        self.res_lat = int(np.ceil((maxlat - minlat)/self.res_rad))
        # define the latitude + longitude grid
        grid_lat = np.linspace(minlat, maxlat, self.res_lat)
        grid_lon = np.linspace(minlon, maxlon, self.res_lon)
        return grid_lat, grid_lon
    
    def get_screens(self, maxdtec, r0 = 1, L0 = 1000, dx = 0.5, seed = None):
        '''
        This method computes the tecscreens for each timestamp and station.
        Parameters
        ----------
        maxdtec : float
            Maximum dtec value on global screen.
        r0 : float, optional
            smallest scale in units of pixels. Default = 1
        L0 : float, optional
            largest scale in units of pixels. Default = 1000
        dx : float, optional
            Velocity of the screen in units of pixels / timestamp.
            Default = 1 rot/day, is calculated below.
            
        Returns
        -------
        screens : (l, 1, m, n, n) array of dtype float
            Array containing the screens for each time (l) and station (m).
            Has square dimensions of n x n where (n-1)/2 is center.    

        '''
        logging.info('Computing screens...')
        # generate global screen generator object. 
        # dx_unit: 1 rotation per day
        dx_unit = (obs.timepersample/(24*3600))*(2*np.pi/self.res_rad)

        screen_generator = MegaScreen(r0, L0, windowShape=[self.res_lat,
                                        self.res_lon], dx=dx*dx_unit, 
                                      theta = np.pi/2, seed = seed)

        # Find correct sector of global screen for each station
        screens = np.zeros((len(self.t),1, len(self.sp), 
                            2*self.station_grid_width+1, 
                            2*self.station_grid_width+1))
        for (i, frames) in enumerate(screen_generator):
            if i == 0:
                plt.imshow(frames)
                plt.savefig('global_frame.png', dpi = 400)
                #np.savetxt('global_frame.txt', frames)
            if i == len(self.t):
                break
            # TODO insert progressbar
            for (j, station) in enumerate(self.sp):
                # Find station on grid
                stat_lat_pos = np.argmin(np.abs(self.grid_lat - self.sp_lat[j]))
                stat_lon_pos = np.argmin(np.abs(self.grid_lon - self.sp_lon[j]))
                lat_idx = [stat_lat_pos - self.station_grid_width,
                           stat_lat_pos + self.station_grid_width + 1]
                lon_idx = [stat_lon_pos - self.station_grid_width,
                           stat_lon_pos + self.station_grid_width + 1]
                frame = frames[lat_idx[0]:lat_idx[1], lon_idx[0]:lon_idx[1]]                
                screens[i,0,j] = frame
        screens *= maxdtec / (np.max(screens) - np.min(screens))
        return screens           
    

    
    
if __name__ == '__main__':
    # Options
    parser = argparse.ArgumentParser()
    parser.add_argument('msfile', help='Input MS filename.', type=str, default=None)
    parser.add_argument("fitsfile", help="Output FITS fileneam", type=str, default=None)
    parser.add_argument("--maxdtec", help="maximum dTEC value in screen", type=float, default=.4)
    parser.add_argument("--dx", help="screen velocity factor", type=float, default=.1)
    parser.add_argument("--seed", help="define random seed", type=int, default=None)

    args = parser.parse_args()
    # Make obs object and get station positions (in m), times, and freqs
    obs = Observation(args.msfile) #TODO
    sp = obs.stationpositions
    times = obs.get_times()
    freqs = obs.get_frequencies()
    
    # generate global screen object    
    screen = spherical_screen(sp, times, height = 200e3, res = 400, 
                              station_grid_rad = 4.)
    imsize = 2 * screen.station_grid_width + 1
    cellsize_deg = np.rad2deg(screen.station_grid_res_rad)
    logging.info('Generating template fits file...')
    make_template_image(args.fitsfile, obs.ra, obs.dec, ximsize=imsize,
                        yimsize=imsize, cellsize_deg=cellsize_deg, freqs=[freqs[0]],
                        times=times, antennas=obs.stations, aterm_type='tec')
    hdu = fits.open(args.fitsfile, memmap=False)
    
    data = hdu[0].data
    # get station screens as data for the .fits file
    data = screen.get_screens(args.maxdtec, dx = args.dx, seed = args.seed)
    # Write out screens
    hdu[0].data = data
    hdu.writeto(args.fitsfile, overwrite=True)
