#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 31 10:14:35 2020

@author: Henrik Edler <henrik.edler@hs.uni-hamburg.de>
"""
import logging
import argparse
import itertools
import multiprocessing as mp
import numpy as np
from scipy.interpolate import RectBivariateSpline
from astropy.io import fits
import astropy.units as u
from astropy.time import Time
from astropy.coordinates import EarthLocation, SkyCoord, ITRS, FK5
from losito.obs import Observation
from losito.operations.faraday import get_PP_PD
from losito.lib_operations import make_template_image
from losito.MegaScreen import MegaScreen

R_earth = 6364.62e3
h_ion = 200.0e3


class spherical_screen():
    ''' 
    Class to resemble a tecscreen. The screen has a certain height above
    the stations and a resolution. The dimensions of the screen are such
    that the edge stations can view a station_grid_rad big section 
    of the screen. This global screen is given in geodetic coordinates. 
    From the global screen the tecscreens for each station are extracted. 
    
    Parameters
    ----------
    sp : (n, 3) array
        Station positions in cartesian coodinates.
    times : (m,) array dtype float 
        Timestamps of the observations.
    height : float, optional
        Height of the tecscreen above the stations in meter. 
        Default 200 km.
    res : float, optional
        Resolution of the tecscreen in meter. 
        Default 1 km.
    station_grid_rad : float, optional
        How big should the screen of a single station be? This is the 
        angular distance from the reference direction to the station screen
        edge in degree. Default: 4Â° (So the screen is ~ 4 FWHM wide)
    '''
    def __init__(self, sp, times, height = 200e3, res = 1e3, 
                 station_grid_rad = 4.):
        self.sp = EarthLocation.from_geocentric(*sp.T, 'meter') # station pos.
        self.sp_lat = self.sp.to_geodetic().lat.rad # station pos. latitudes
        self.sp_lon = self.sp.to_geodetic().lon.rad # station pos. longitudes
        self.t = times # timestamps of observation
        self.h = height # height of tecscreen
        self.r = 6364.62e3;  # earth radius in m
        self.res = res # resolution of screen grid in m
        self.res_rad = res/(self.r + self.h) # resolution of screen grid in rad
        self.station_grid_rad = np.deg2rad(station_grid_rad) # see class descr.
        self.grid_lat, self.grid_lon = self.get_lat_lon_grid() # initialize
        #station_grid_width: half-width of the station grid in grid index steps
        self.station_grid_width = int(self.delta_angle/self.res_rad)
        self.station_grid_res_rad = res/self.h # get from lat-lon angles to elev
        
    def get_lat_lon_grid(self):
        ''' 
        Initialize the geometry of the global grid.

        Returns
        -------
        grid_lat : ndarray
            Latitude values of the global grid.
        grid_lon : ndarray
            Longitude values of the global grid.
        '''
        r = self.r
        # Calculate extrema of lat/lon to find grid edges.
        # do this using law of sines
        sp_minlat, sp_maxlat = np.min(self.sp_lat), np.max(self.sp_lat)
        sp_minlon, sp_maxlon = np.min(self.sp_lon), np.max(self.sp_lon)
        # delta_angle: angle between ray from earth center to ref_dir
        # and ray from earth center to point on edge of station_screen
        self.delta_angle = (self.station_grid_rad - np.arcsin(
            np.sin(np.pi - self.station_grid_rad) * (r / (r + self.h))))        

        minlat = sp_minlat - self.delta_angle    
        maxlat = sp_maxlat + self.delta_angle
        minlon = sp_minlon - self.delta_angle
        maxlon = sp_maxlon + self.delta_angle       
        #archlength_lat = (maxlat - minlat)*(r + self.h)
        #archlength_lon = (maxlon - minlon)*(r + self.h)
        self.res_lon = int(np.ceil((maxlon - minlon)/self.res_rad))
        self.res_lat = int(np.ceil((maxlat - minlat)/self.res_rad))
        # define the latitude + longitude grid
        grid_lat = np.linspace(minlat, maxlat, self.res_lat)
        grid_lon = np.linspace(minlon, maxlon, self.res_lon)
        return grid_lat, grid_lon
    
    def get_screens(self, maxdtec, r0 = 1, L0 = 1000, dx = 0.5, seed = None):
        '''
        This method computes the tecscreens for each timestamp and station.
        Parameters
        ----------
        maxdtec : float
            Maximum dtec value on global screen.
        r0 : float, optional
            smallest scale in units of pixels. Default = 1
        L0 : float, optional
            largest scale in units of pixels. Default = 1000
        dx : float, optional
            Velocity of the screen in units of pixels / timestamp.
            Default = 1 rot/day, is calculated below.
            
        Returns
        -------
        screens : (l, m, n, n) array of dtype float
            Array containing the screens for each time (l) and station (m).
            Has square dimensions of n x n where (n-1)/2 is center.    

        '''
        logging.info('Computing screens...')
        # generate global screen generator object. 
        # dx_unit: 1 rotation per day
        dx_unit = (obs.timepersample/(24*3600))*(2*np.pi/self.res_rad)

        screen_generator = MegaScreen(r0, L0, windowShape=[self.res_lat,
                                        self.res_lon], dx=dx*dx_unit, 
                                      theta = np.pi/2, seed = seed)

        # Find correct sector of global screen for each station
        screens = np.zeros((len(self.t),1, len(self.sp), 
                            2*self.station_grid_width+1, 
                            2*self.station_grid_width+1))
        for (i, frames) in enumerate(screen_generator):
            if i == 0:
                pass
                #plt.imshow(frames)
                #plt.savefig('global_frame.png', dpi = 400)
                #np.savetxt('global_frame.txt', frames)
            if i == len(self.t):
                break
            # TODO insert progressbar
            for (j, station) in enumerate(self.sp):
                # Find station on grid
                stat_lat_pos = np.argmin(np.abs(self.grid_lat - self.sp_lat[j]))
                stat_lon_pos = np.argmin(np.abs(self.grid_lon - self.sp_lon[j]))
                lat_idx = [stat_lat_pos - self.station_grid_width,
                           stat_lat_pos + self.station_grid_width + 1]
                lon_idx = [stat_lon_pos - self.station_grid_width,
                           stat_lon_pos + self.station_grid_width + 1]
                frame = frames[lat_idx[0]:lat_idx[1], lon_idx[0]:lon_idx[1]]                
                screens[i,0,j] = frame
        screens *= maxdtec / (np.max(screens) - np.min(screens))
        return screens   
    
def daytime_from_mjds(t):
    ''' Turn an array of modified julian day seconds into an array
    containing the day hour, including decimal fraciton.
    Parameters
    ----------
    t : (n,) ndarray. MJDseconds timestamps.
    Returns
    -------
    hours : (n,) ndarray. Daytime hours.
    '''
    jd = Time(t/(3600.*24.), format = 'mjd')
    hours = np.array([step.hour for step in jd.to_datetime()])
    fracs = np.array([step.minute/60. for step in jd.to_datetime()])
    return hours + fracs


def daytime_tec_modulation(t):
    ''' Get the tec modulation values corresponding to the daytime derived
    from mjds timestamps. Peaking at 15h, with a tecmax/tecmin ration of 10.
    Parameters
    ----------
    t : (n,) ndarray. MJDseconds timestamps
    Returns
    -------
    modulation : (n,) ndarray. TEC modulation, between 0.05 and 1.
    '''
    # TODO: longitude dependency of modulation. 
    hours = daytime_from_mjds(t)
    modulation = 0.45 * np.sin((hours - 9)*np.pi/12.) + 0.55
    return modulation 
    
def geocentric_to_geodetic(points):
    ''' Geocentric XYZ to longitude and latitude conversion.
    The input points can have arbitrary shape, the only restriction is that
    the last axis has length of 3 and corresponds to X/Y/Z.
    Parameters
    ----------
    points : (...,3) ndarray
        Input points
    Returns
    -------
    LonLatR: (...,3) ndarray           
            lon : (...,) ndarray
                Corresponding longitude in rad 
            lon : (...,) ndarray
                Corresponding latitude in rad
            R : (...,) ndarray
                Corresponding radius.
    '''
    R = np.linalg.norm(points, axis = -1)
    lon = np.arctan2(points[...,1], points[...,0])
    lat = np.arcsin(points[...,2]/R)
    return np.moveaxis(np.array([lon, lat, R]), 0, -1)
    
def screen_grid(edges, gridsize, R_earth = 6364.62e3, h_ion = 200.0e3):
    '''
    
    Parameters
    ----------
    edges : (4,) ndarray
        Pierce point edges in minlon, maxlon, minlat, maxlat. (Radians)
    gridsize : int
        Resolution of the greater grid axis.
    R_earth : TYPE, optional
        DESCRIPTION. The default is 6364.62e3.
    h_ion : TYPE, optional
        DESCRIPTION. The default is 200.0e3.

    Returns
    -------
    None.

    '''
    min_lon, max_lon, min_lat, max_lat,  = edges
    lat_wdth, lat_center = max_lat - min_lat, np.mean([max_lat, min_lat])    
    # To get similar length scale res, cosine factor
    lon_wdth = (max_lon - min_lon) 
    res_rad = np.max([lat_wdth, lon_wdth * np.cos(lat_center)]) / gridsize
    res_lon = res_rad / np.cos(lat_center)
    
    pixel_lat = np.ceil(lat_wdth/res_rad)
    pixel_lon = np.ceil(lon_wdth/res_lon)  
    
    grid_lat = np.linspace(min_lat, max_lat, pixel_lat)
    grid_lon = np.linspace(min_lon, max_lon, pixel_lon)
    # update resolution to get rid of rounding error
    cellsz_lat = lat_wdth/pixel_lat
    cellsz_lon = lon_wdth/pixel_lon
    
    return grid_lon, grid_lat, cellsz_lon, cellsz_lat
    
    
def get_tecscreen(sp, direction, times, size, h_ion = 200.e3, maxvtec = 50., 
                  maxdtec = 1., ncpu = None, savefile = None):
    ''' Return a tecscreen-array. The TEC values represent a daily 
    sinusoidal modulation peaking at 15h, overlaid with von Karman 
    turbulences. 
    Parameters
    ----------
    PP : (l,m,n,3) ndarray
        Ionospheric pierce points in geocentric coordinates.
        Axes correspond to (time, station, direction, xyz)
    PD : (l,n,3) ndarray
        Pierce directions in geocentric coords. (time, direction, xyz)
    times : (n,) ndarray
        Timestamps in MJDseconds
    size : int
        Size of the greater screen axis.
    maxvtec : float, optinal. Default = 50.
        Daytime vTEC peak value for tec modulation in TECU.
    maxdtec : float, optional. Default = 1.
        Maximum allowed dTEC of the screen for a single timestep. 
    savefile: str, optional. Default = None.
        Filename of the output .npy tecscreen array.   
        
    Returns
    -------
    tecscreen : (n, i, j) ndarray
        TECscreen time dependent grid, the axes are (time, lon, lat)
    '''    
    if ncpu == 0:
        ncpu = mp.cpu_count()
    # Get the ionospheric pierce points)
    PP, PD = get_PP_PD(sp, directions, times, h_ion, ncpu)   

    # Find the outermost piercepoints to define tecscreen size:
    PP_llr = geocentric_to_geodetic(PP)
    edges = [np.min(PP_llr[...,0]), np.max(PP_llr[...,0]), 
             np.min(PP_llr[...,1]), np.max(PP_llr[...,1])]
    grid_lon, grid_lat, cellsz_lon, cellsz_lat = screen_grid(edges, size)
    # Get turbulent screen generator object and convert to array
    it = MegaScreen(1, 1000, windowShape = [len(grid_lon), len(grid_lat)], 
               dx = 1, theta = 0, seed = 10, numIter = len(times))
    tecsc = np.array(list(it)) # this can't be parallelized :(
    # Rescale each timestep screen to have max dtec 
    tecsc *= maxdtec / (np.max(tecsc, axis=0) - np.min(tecsc, axis=0))
    tecsc = (daytime_tec_modulation(times)[:,np.newaxis,np.newaxis]
             * (tecsc + maxvtec))
    if savefile:
        np.save(savefile, tecsc)
        logging.info('Save TEC screen to file: ' + savefile)
        
    data = np.zeros((len(times), len(sp), len(directions)))
    PP*PD[:,np.newaxis]
    for (i, sc) in enumerate(tecsc): # iterate times
        f = RectBivariateSpline(grid_lon, grid_lat, sc)
        a = f.ev(PP_llr[i,:,:,0], PP_llr[i,:,:,1])
        data[i] = a
    print(data)
    return data
        
    

if __name__ == '__main__':
    # Options
    ncpu = 6
    parser = argparse.ArgumentParser()
    parser.add_argument('msfile', help='Input MS filename.', type=str, default=None)
    #parser.add_argument("fitsfile", help="Output FITS fileneam", type=str, default=None)
    #parser.add_argument("--maxdtec", help="maximum dTEC value in screen", type=float, default=.4)
    #parser.add_argument("--dx", help="screen velocity factor", type=float, default=.1)
    #parser.add_argument("--seed", help="define random seed", type=int, default=None)

    args = parser.parse_args()
    # Make obs object and get station positions (in m), times, and freqs
    obs = Observation(args.msfile, 'mock.sky') #TODO skymdoel
    sp = obs.stationpositions
    directions = np.asarray(obs.get_patch_coords()).T
    times = obs.get_times()[-100:]
    
    data = get_tecscreen(sp, directions, times, 400, h_ion = 200.e3, 
                         maxvtec = 50., maxdtec = 1.,  ncpu = ncpu)
    import sys
    sys.exit()
    
    # generate global screen object    
    imsize = 2 * screen.station_grid_width + 1
    cellsize_deg = np.rad2deg(screen.station_grid_res_rad)
    logging.info('Generating template fits file...')
    make_template_image(args.fitsfile, obs.ra, obs.dec, ximsize=imsize,
                        yimsize=imsize, cellsize_deg=cellsize_deg, freqs=[freqs[0]],
                        times=times, antennas=obs.stations, aterm_type='tec')
    hdu = fits.open(args.fitsfile, memmap=False)
    
    data = hdu[0].data
    # Write out screens
    hdu[0].data = data
    hdu.writeto(args.fitsfile, overwrite=True)

